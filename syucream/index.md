Title: SHOW BY QUIC!!
Subtitle: 青春はNon-(HoL)Blocking!
Author: @syu_cream
Author(romaji): syu_cream

# SHOW BY QUIC!!

こんにちは、 @syu_cream です。
本記事では、[ITMedia の記事](http://www.itmedia.co.jp/news/articles/1504/20/news046.html) などで最近一部界隈を賑わしている、仕様の Internet-Draft も発行されている、 Google が提唱する高速プロトコル [QUIC](http://tools.ietf.org/html/draft-tsvwg-quic-protocol-00) について特徴や仕様、そして実装の簡単な紹介をしてみようと思います。

記事の内容には注意を払ってはおりますが、正確性が保証されているものではありません。気になる箇所についてはぜひ、ご自身で仕様のドラフトや実装を読んで確かめてみてください。（そしてこっそりご報告いただけると幸いです ... :D）
また、 QUIC は仕様がドラフトの状態であり、将来的に大きな変更がある可能性がありますのでご注意ください。

なお、 QUIC に関連するプロトコルとして本記事では HTTP/2 についても多く触れますが、詳細な説明は行いません。
QUIC について記述する上で重要な箇所については触れますが、詳細についてはぜひご自身で [RFC7540(HTTP/2 の RFC)](https://tools.ietf.org/html/rfc7540) や、 [ななかINSIDE PRESS vol.5](https://sites.google.com/site/dai7sec/home/c86) を参照しつつ読んで頂ければ幸いです。
ちなみに HTTP/2 と HTTP/2 に関連するヘッダ圧縮フォーマット HPACK の RFC については、それぞれ有志による [RFC7540 の日本語訳](http://summerwind.jp/docs/rfc7540/), [RFC7541 の日本語訳](http://syucream.github.io/hpack-spec-ja/rfc7541-ja.html) が存在し、英語を読むのが面倒という方にも敷居が低い状態になっています。


## QUIC とは

QUIC(Quick UDP Internet Connection) は HTTP 通信の高速化のために HTTP/2 から更に進んだ最適化を行うプロトコルです。
とは言っても単純に HTTP/2 をそのまま置き換えるようなプロトコルではありません。
TCP + TLS + HTTP/2 というスタックをやめて、 UDP 上に TCP + TLS でやっていたような高信頼性、セキュアな通信を実現しつつ TCP + TLS によって犠牲になっていた性能を向上し、かつ HTTP/2 のレイヤで行っていたストリーム管理などの複雑なロジックを受け持つことでアプリケーションレイヤの実装のシンプル化も図るような設計になっています。
HTTP/2 との関係を図にすると下記のようになります。

(ここに図を貼る)
図1. QUIC と TCP, TLS, HTTP/2 の関係

さて、そもそも既存の TCP + TLS に乗っかったウェブの世界では何が課題になっていて、 QUIC ではそれらがどのように解決されるのでしょうか。
まずはそこから追ってみましょう。

### TCP + TLS + HTTP/2 の世界

[RFC7540](https://tools.ietf.org/html/rfc7540) では HTTP 通信を高速化するため、 HTTP/1.1 の置き換えとして HTTP/2 が提案されました。
HTTP/2 は TCP, TLS の上に乗っかっており、これによって幾つかの課題が残っている状態です。

HTTP/2 通信を TCP, TLS 上で行うことによって、下記のような課題が未だ残っています。

* HTTP リクエストが送れるようになるまで通常 3 ラウンドトリップ必要
* TCP の HoL ブロッキングによるパフォーマンス低下

### QUIC が実現する世界

ここでは QUIC の詳細な仕組みは後述し、まずは QUIC のメリットに着目してみます。
TCP + TLS + HTTP/2 の構成と比べ、 QUIC + HTTP/2 の構成では下記のようなアドバンテージが生じます。

* セッション確立のレイテンシが低い
* TCP の HoL ブロッキングのない通信の多重化
* コネクションマイグレーションが可能

また、 TCP, TLS を置き換えることによって、それぞれのレイヤで行っていた処理を柔軟に置き換えることもできます。
ここでは詳細には触れませんが、下記のようなメリットが生じます。

* 柔軟な輻輳制御
* ヘッダとペイロードの認証、暗号化
* 誤り訂正

先に挙げた3つの特徴は、 QUIC を導入する大きなメリットになってきそうです。
詳細を見ていきましょう。

#### セッション確立のレイテンシが低い

ご存知の通り TCP + TLS では HTTP 通信が可能になるまで通常では 3 ラウンドトリップを要します。
TLS の Session resumption や False Start を行うことによってセッション確立までのラウンドトリップを減らすことができますが、それでも 2 ラウンドトリップは要します。

(ここに図)
図2. 一般的な TCP + TLS のセッション確立シーケンス

(ここに図)
図3. Session resumption した際のセッション確立シーケンス


これに対し、 QUIC では多くの場合コネクションの確立にラウンドトリップを要しません。

QUIC クライアントが QUIC サーバに対してはじめてリクエストを送る際、 1 ラウンドトリップを要します。
この際にクライアントは空の CHLO(Client Hello) メッセージを送り、それに対してサーバは REJ(rejection) メッセージを返します。
REJ メッセージには 1) その後の CHLO においてクライアント IP を検証するためのソースアドレストークン 2) サーバ証明書 を含みます。
次回リクエスト送信時からは、 REJ メッセージに含まれたクレデンシャルと一緒に暗号化されたリクエストを CHLO メッセージで送ることで、セッション確立のフェーズを無くすことができます。

(ここに図)
図4. QUIC のセッション確立

(ここに図)
図5. 以前のセッション確立時のクレデンシャルを用いたリクエスト送信

#### TCP の HoL ブロッキングのない通信の多重化

個人的には QUIC の解決する課題の中で一番インパクトがあったのがこれ、 TCP の HoL(Head of Line) ブロッキングの解消です。
... と言うのは良いのですが、そもそも TCP の HoL ブロッキングというのはどのような問題なのでしょうか。

ご存知の通り TCP ではパケットの到着順序が保証されており、送信された順に受信側でバッファから読み取れるようになります。
順序保証によって、より高レイヤでパケットの順序を意識しなくて良くなるという大きなメリットが生じます。
ただし、この順序保証によってパフォーマンスが阻害される場合も存在ます。

下図のように、あるパケットがロスし、それに続くパケットが受信側に到達した場合どうなるでしょうか。
この場合、ロスしたパケットが再送されるわけですが、再送が完了されるまでその後に続くパケットはバッファに蓄積された状態でアプリケーションには処理されません。
このようにパケットロスによってそれに続くパケットの処理がブロックされる問題を、 TCP の HoL ブロッキングと言います。

(ここに図)
図6. TCP の HoL(Head of Line) ブロッキング

では QUIC ではこの HoL ブロッキングの問題はどうなっているのでしょうか？
と言っても答えは単純明快です。 QUIC ではそもそも TCP ではなく UDP の上に展開しているので、 TCP の HoL ブロッキングは起こりません。
ただし、もちろんパケットロスの検出や再送処理も自前で実装する必要が出てきます。

（ちなみに、 TCP の HoL ブロッキングが無くなったからプロトコル処理でブロックする要素はもう無いんだ！という訳にもいきません。後述しますがヘッダ処理周りでブロックされる可能性があります。。）

shigeki_ohtsu さんによる、前述の [セッション確立と、 HoL ブロッキングの解消によるインパクトを可視化した動画](https://www.youtube.com/watch?v=bP-8vfDX2ts) が youtube にて公開されています。
QUIC のこの周辺の効果を体感したい際に参照すると良いかもしれません。

#### コネクションマイグレーション

TCP のコネクションは送信元 IP とポート、宛先 IP とポートから識別されるため、例えば送信元 IP が変わった際は一旦コネクションが切れることになります。
これは例えばスマートフォンでモバイル回線から WiFi に切り替わった際に発生することになり、今日では非常に煩わしい問題だと考えられます。

QUIC のコネクションは TCP のコネクションとは違って、独自の 64 ビットの ID によって識別され、これが変更されない限りコネクションは切断されません。


## QUIC 詳解

ここではより QUIC の仕様に踏み込み、具体的にどのようなメッセージをやりとりし、その時何が起きるのかを掘り下げてみます。

まず QUIC の大まかな特徴を確認し、次に QUIC におけるメッセージの単位であるパケットとフレームについて触れ、それらがどうやりとりされてリクエストやレスポンスが処理されるのかを追ってみます。
ちなみにここでは、単に「パケット」「フレーム」と記述した際は、 QUIC におけるメッセージ単位の「QUIC のパケット」「QUIC のフレーム」と解釈してください。

### QUIC の特徴

QUIC は下記のようなプロトコルになっています。

* コネクションによる通信の管理

UDP はコネクションレスなプロトコルですが、その上で展開する QUIC はコネクションの概念が存在します。
TCP ではコネクションを送信元 IP 、送信先 IP 、送信元ポート番号、送信先ポート番号で識別しましたが、 QUIC では各コネクションにランダムかつユニークな符号無し64ビット整数値で表現される ID で識別します。

* 誤り検出 FEC (Forward Error Collection)

* フロー制御

* 輻輳制御

* 認証、暗号化

* ストリームによるコネクション上の通信の多重化

### QUIC パケット

QUIC でやり取りされるメッセージにはまずパケットという単位があります。
QUIC のパケットは下記の 4 種類が存在します。

1. バージョンネゴシエーションパケット

TBD

2. フレームパケット

QUIC でやりとりする主たるメッセージであるフレームを表現します。
フレームにもいくつかの種類があります。（後述

3. FEC (Forward Error Collection) パケット
4. Public Reset パケット

### QUIC フレーム

QUIC も HTTP/2 と同様にフレームという形式でメッセージを表現します。
フレームには大きく分けて、スペシャルフレームとレギュラーフレームの 2 種類が存在します。
この種類ですが、スペシャルフレームは場合に応じてフラグを変更してフレーム内のデータ長を変動させるなどの表現が備わっていますが、レギュラーフレームにはそれが無いなどの差分があります。

#### スペシャルフレーム

* STREAM フレーム

このフレームの役割は二つ、 1) ストリームの新規作成 2) データの送信 です。
HTTP/1.1 におけるリクエストやレスポンスのボディ、 HTTP/2 における最初の HEADERS フレームや DATA フレームの役割に相当します。

* ACK フレーム

TCP の ACK と似たような役割で、ピアに対してパケットが受け取れたことを伝えます。
ACK フレームが返ってこなかった場合は、パケットの再送が必要と判断されます。
TCP の ACK とは違って、ロスしたパケットの Sequence Number 一覧や NACK、 Sequence Number のレンジを伝える方法も提供されています。

* CONGESTION_FEEDBACK フレーム

#### レギュラーフレーム

* PADDING フレーム

名前の通りパディングを示します。
PADDING フレームが現れた際は、そのパケットのペイロードは末尾までパディングとして扱われます。
PADDING フレーム自身のペイロードの内容は特に規定はありません。タイプだけが 0x00 であると決められています。

* RST_STREAM フレーム

基本的に HTTP/2 の RST_STREAM フレームと同じ役割です。
ストリームが不要になってキャンセルする場合や、エラーなどが原因でストリームを終了する場合にやり取りされます。

* CONNECTION_CLOSE フレーム

コネクションが閉じられようとしていることをピアに伝えます。
なお、コネクションが閉じられる際にはその上で動作している全ストリームも閉じられることになります。
もしこの時、データ転送など絶賛稼働中のストリームがあったとしても途中で強制終了されることになります。

* GOAWAY フレーム

基本的に HTTP/2 の GOAWAY フレームと同じ役割です。
近い将来にコネクションが閉じられようとしていることを伝える、 CONNECTION_CLOSE フレームと似たような役割を持つのですが、こちらはすぐにコネクションを閉じることはしません。
動作中のストリームはそのまま処理を続けることができます。ただし、ストリームを新たに開いたり受け付けたりすることはできなくなります。

* WINDOW_UPDATE フレーム

基本的には HTTP/2 の WINDOW_UPDATE フレームと役割は一緒で、フロー制御に使用されます。
ピアに対して、指定ストリームの受信ウインドウサイズが、送信する値分増加することを伝えます。
もしストリーム ID が 0 のストリームに対する WINDOW_UPDATE フレームがやりとりされたら、それはコネクションレベルのウインドウサイズの増加であると解釈されます。

* BLOCKED フレーム

これは前述の WINDOW_UPDATE フレームとも深い関わりのあるフレームです。
データの送信側が、送信準備は整っているのに受信側のウインドウサイズが更新されず、送信処理がブロックされていることを伝えます。
とは言っても、 BLOCKED フレームが送受信された際に何かしなければならないという規定はありません。あくまでブロック情報を伝えるだけの、デバック用途に向いたフレームといえます。

* STOP_WAITING フレーム

プレームのペイロードに設定する値より低い Sequence Number のパケットを待たないようにピアに伝えます。

* PING フレーム

ピアとの接続が使用可能な状態か確かめます。
PING フレームを受け取ったピアは ACK を返すことになっています。

### コネクションの確立

UDP はコネクションレスのプロトコルですが、その上で動作する QUIC にはコネクションの概念があります。
QUIC のコネクションはクライアントがサーバに対して接続要求を開始することで確立します。
コネクション開始時には、使用する QUIC のバージョンのネゴシエーションと暗号と転送方法のハンドシェイクを行います。
これはラウンドトリップを減らすために一緒くたに実施されます。

バージョンのネゴシエーション ...

### データ転送

### ストリームの状態管理

### コネクションの終了


## QUIC と HTTP/2 の機能の住み分け

これまで追ってきた QUIC の機能ですが、そのいくつかは RFC7540 で規定されている HTTP/2 の機能と重複しています。
もちろんの事ながら、全く同じ機能を上位レイヤに持たせても無駄でありますから、 QUIC 上で動作する HTTP/2 は QUIC がカバーしてくれない仕事のみを行うべきです。

さて、 TCP + TLS を QUIC に置き換わった際、 HTTP/2 ではどんな処理を行う必要があるのでしょうか。

### ストリーム管理

HTTP/2 で行っていたストリーム管理は、 そのほとんどが QUIC のストリーム管理に任せることができます。
HTTP/2 のレイヤではもはや RFC7540 で記述されていたような、 HEADERS, DATA などのフレームによるヘッダ、ボディの表現を意識しなくてよくなります。
また、 ストリーム ID は QUIC のストリーム ID を用います。

フロー制御についても QUIC のレイヤで行われます。
QUIC のフロー制御は HTTP/2 のそれを機能的にカバーすることができ、 HTTP/2 のレイヤで再度行う必要はありません。
TCP + TLS + HTTP/2 では TCP と HTTP/2 、両方でフロー制御を行っていたのが一本化されるので、これは順当な置き換えと言えそうですね。

### ヘッダ圧縮

QUIC では HTTP/2 と同様、 RFC7541 で規定されている [HPACK](http://tools.ietf.org/html/rfc7541) を使用してヘッダを圧縮します。

しかしながら、実は HPACK を使用することで新たに HoL ブロッキングが発生することになります。。。
というのも、 RFC7541 を読めばわかる通り、 HPACK ではヘッダの圧縮、展開が順番に行われるためです。
例えばヘッダをデコード中、途中のヘッダ内容を格納するフレームがパケットロスにより失われたとしても、その後に続くヘッダをデコードすることは HPACK の仕様上叶わなくなります。

QUIC によるヘッダの送受信はヘッダストリームという、ヘッダ専用ストリーム（とは言っても ID が 3 のストリームを特別にそう扱っているだけ）を用いて行います。
受信処理において、ヘッダの処理が終わってからボディの処理を行うことになります。

### ストリームの優先度とヘッダストリーム

HTTP/2 では 各ストリームに優先度を設定することができました。
これは例えばブラウザ側で Web ページのレンダリングを早く行うために CSS が優先的に求められると判断した際に、それを優先する旨をサーバ側に通知するなどに使うことができます。

QUIC ではストリームの優先度については特になにも行いません。
優先度情報を伝搬させる手段として、ヘッダストリームにおいてヘッダの先頭部分に優先度を設定することができます。
ただし、優先度をどう活用するかは HTTP/2 のレイヤに委ねられることになります。

ヘッダストリームに流れるオクテットストリームは下記のようなフォーマットをとります。

```
     0           3      4          7      8           11   12
+--------+- ... ---+--------+- ... --+--------+- ... ---+------ ...
|     Priority     |    Stream ID    |  Headers length  | Headers
+--------+- ... ---+--------+- ... --+--------+- ... ---+------ ...

* Priority: 32 ビットの優先度値
* Stream ID: QUIC のストリーム ID に紐付いた HTTP/2 における 32 ビットのストリーム ID
* Header length: 32 ビットのヘッダの長さ
* Headers: HPACK で圧縮されたヘッダ
```

### Alternate-Protocol ヘッダによるプロトコルネゴシエーション

HTTP/2 では、クライアントがサーバに対してリクエストを送る前に、サーバが HTTP/2 に対応しているかを調べる方法として TLS の拡張である [NPN](http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04) や [ALPN](https://tools.ietf.org/html/rfc7301) を使ってネゴシエートすることができました。

QUIC ではどうなのかというと、今のところリクエストを送る前にピアが QUIC に対応しているかを調べる手段は提供されていません。
しかしながら TCP + TLS + HTTP (HTTP/1.1, SPDY, HTTP/2) でリクエストを受け付けた際に、「 QUIC でもレスポンスできる」ことを示す手段は QUIC の仕様に定められています。
それが Alternate-Protocol ヘッダです。

Alternate-Protocol ヘッダは下記のような形式をとります。
このヘッダは、ヘッダを返した際のリクエストのドメインに関して、「123 ポートで QUIC でリクエストを受け付けることができる」ことを意味します。
```
"Alternate-Protocol: 123:quic"
```

ただし、このヘッダで確認できるのはサーバ側のプロトコルサポートの都合だけです。
実際に QUIC を使う場合は、中継装置により QUIC （というかそもそも UDP の）通信がブロックされる可能性があります。
従ってクライアントは Alternate-Protocol の情報をもとに QUIC リクエストを投げるのは良いのですが、それを鵜呑みにせず駄目だった際に TCP + TLS + HTTP 通信にフォールバックできるように実装されることが望まれます。


## Chromium の実装読み

Chromium の実装を読んで、関心のあるところを詳解


## おわりに

