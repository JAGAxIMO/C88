Title: SHOW BY QUIC!!
Subtitle: 青春はNon-(HoL)Blocking!
Author: @syu_cream
Author(romaji): syu_cream

# SHOW BY QUIC!!

こんにちは、 @syu_cream です。
本記事では、[ITMedia の記事](http://www.itmedia.co.jp/news/articles/1504/20/news046.html) などで最近一部界隈を賑わしており、仕様の Internet-Draft も発行されている、 Google が提唱する高速プロトコル [QUIC(Quick UDP Internet Connection)](http://tools.ietf.org/html/draft-tsvwg-quic-protocol-00) について特徴や仕様、そして実装の簡単な紹介をしてみようと思います。

記事の内容には注意を払ってはおりますが、正確性が保証されているものではありません。気になる箇所についてはぜひ、ご自身で仕様のドラフトや実装を読んで確かめてみてください。（そしてこっそりご報告いただけると幸いです ... :D）
また、 QUIC は仕様がドラフトの状態であり、将来的に大きな変更がある可能性がありますのでご注意ください。

QUIC を語る上で、 HTTP の次期メジャーバージョンでもあり今年 2015年 5 月に RFC も発行された HTTP/2 に関する、ある程度の知識が求められます。
QUIC について記述する上で重要な箇所については触れますが、紙面の関係上詳細部分に関しては端折って記述します。
詳細についてはぜひご自身で [RFC7540(HTTP/2 の RFC)](https://tools.ietf.org/html/rfc7540) や、 [ななかINSIDE PRESS vol.5](https://sites.google.com/site/dai7sec/home/c86) を参照して確認して頂ければ幸いです。
ちなみに HTTP/2 と、 HTTP/2 に関連するヘッダ圧縮フォーマット HPACK の RFC については、それぞれ有志による [RFC7540 の日本語訳](http://summerwind.jp/docs/rfc7540/), [RFC7541 の日本語訳](http://syucream.github.io/hpack-spec-ja/rfc7541-ja.html) が存在し、英語を読むのが面倒という方にも敷居が低い状態になっています。


## QUIC とは

QUIC(Quick UDP Internet Connection) は HTTP 通信の高速化のために HTTP/2 から更に進んだ最適化を行うプロトコルです。
とは言っても単純に HTTP/2 を置き換えるようなプロトコルではありません。
TCP + TLS + HTTP/2 というスタックをやめて、 UDP 上に TCP + TLS でやっていたような高信頼性、セキュアな通信を実現しつつ TCP + TLS によって犠牲になっていた性能を向上し、かつ HTTP/2 のレイヤで行っていた複雑なロジックを受け持つことでアプリケーションレイヤの実装のシンプルにするような設計になっています。
HTTP/2 との関係は下図のようになります。

![図1. QUIC と TCP, TLS, HTTP/2 の関係](img/fig01.png)

さて、そもそも既存の TCP + TLS + HTTP/2 の世界では何が課題になっていて、 QUIC ではそれらがどのように解決されるのでしょうか。
まずはそこから追ってみましょう。

### TCP + TLS + HTTP/2 の世界

#### HTTP/2 の特徴

[RFC7540](https://tools.ietf.org/html/rfc7540) では HTTP 通信を高速化するため、 HTTP/1.1 の次期バージョンとして HTTP/2 が提案されました。
HTTP/2 は HTTP/1.1 と同じように基本的に TCP, TLS の上に乗っかることを想定されています。

HTTP/2 では下記のような特徴で HTTP/1.1 より高速で柔軟な通信を実現します。

* ストリームという論理的な通信単位の導入による並列リクエスト処理

HTTP/2 では原則的にサーバに対してコネクションを張り続けて、その上にストリーム（論理的なコネクション）を張り、ストリーム毎にリクエストとレスポンスをやり取りすることになります。
HTTP/1.1 と比べコネクションが維持される状態が続き、コネクション確立の TCP の 3 ウェイハンドシェイクや TLS のハンドシェイクのレイテンシが削減できることになります。
また、一般的なブラウザではサーバを配慮してコネクションを張りすぎないよう、並列に投げるリクエスト数を制限していることが多々あるのですが、 HTTP/2 ではコネクションを複数張ることが原則的になくなるので、並列度を上げることができます。

なお、ストリームの概念の導入によりフロー制御は TCP で行っているものでは不十分な状態になります。
TCP のフロー制御はコネクション単位で行われるので、その上で張られる各ストリームに対する細かい制御は効かず、結果として特定のストリームだけが独占的に転送を行うような結果を招きかねません。
これを配慮して、 HTTP/2 では独自にストリームレベルでフロー制御を行えるような機能を持っています。

* 優先度付きリクエスト処理

HTTP/1.1 ではリクエストの優先順位を配慮してレスポンスを返すような機構はなく、多くの実装ではリクエストが来た順に処理されます。
（これを配慮して、 Firefox では CSS などの優先すべきリソースがあればそれらのリクエストを他のリソースの為のリクエストより先に送るようにするよう実装されているようです）
HTTP/2 ではリクエストごとに重み付けや依存関係を記述することができます。
この情報を付与したリクエストをサーバに送ることで、サーバはクライアントが早めに欲しいレスポンスを見分けることができ、それらを優先的に処理するような実装が可能になります。

* ヘッダの圧縮

HTTP/1.1 までの HTTP のヘッダはプレーンテキストであり、 User-Agent のような毎回同じような値になるヘッダも毎リクエストで都度送ることになっていました。
HTTP/2 では [HPACK](http://tools.ietf.org/html/rfc7541) という独自のフォーマットでヘッダを圧縮します。
HPACK では下記のようなヘッダ表現を行い、ヘッダの転送量を削減します。

1. よく使用されるヘッダをインデックスだけで指定できるようにする
2. 以前送ったヘッダを記憶し、インデックスだけで使いまわせるようにする
3. ヘッダの名前や値をハフマンエンコーディングする

* サーバプッシュ

HTTP/2 ではサーバ側でクライアントが欲すると思われるリソースを能動的に送信することができます。
これにより、例えば「index.html に対するリクエストが来た際にそのページの表示に必要になる CSS も転送する」ような挙動が実現できます。

しかしながら HTTP/2 の日本のコミュニティにより、サーバプッシュをうまく扱うのは難しく、前述の優先度を適切に処理する方が効果は高いのではとの指摘もされています。
サーバプッシュが気になる方は、 [@summerwind さんによるサーバプッシュの考察スライド](https://speakerdeck.com/summerwind/2-server-push-considered-harmful) を確認してみるとよいかもしれません。

#### TCP + TLS + HTTP/2 の課題

HTTP/2 は既存の HTTP の性能向上のため多くの改良が入っています。
HTTP/2 はデプロイの容易性に配慮して、 TCP + TLS の上に構築されているのですが、 TCP + TLS を使うことで下記のような課題も残されています。

* HTTP リクエストが送れるようになるまで通常 3 ラウンドトリップ必要

ご存知の通り TCP + TLS では HTTP 通信が可能になるまで通常では 3 ラウンドトリップを要します。
TLS の Session resumption や False Start を行うことによってセッション確立までのラウンドトリップを減らすことができますが、それでも 2 ラウンドトリップは要します。

![図2. 一般的な TCP + TLS のセッション確立シーケンス](img/fig02.png)

* TCP の HoL ブロッキングによるパフォーマンス低下

ご存知の通り TCP ではパケットの到着順序が保証されており、送信された順に受信側でバッファから読み取れるようになります。
順序保証によって、より高レイヤでパケットの順序を意識しなくて良くなるという大きなメリットが生じます。
ただし、この順序保証によってパフォーマンスが阻害される場合も存在ます。

下図のように、あるパケットがロスし、それに続くパケットが受信側に到達した場合どうなるでしょうか。
この場合、ロスしたパケットが再送されるわけですが、再送が完了されるまでその後に続くパケットはバッファに蓄積された状態でアプリケーションには処理されません。
このようにパケットロスによってそれに続くパケットの処理がブロックされる問題を、 TCP の HoL ブロッキングと言います。

![図3. TCP の HoL(Head of Line) ブロッキング](img/fig03.png)

### QUIC が実現する世界

ここでは QUIC の詳細な仕組みは後述し、まずは QUIC のメリットに着目してみます。
TCP + TLS + HTTP/2 の構成と比べ、 QUIC + HTTP/2 の構成では下記のようなアドバンテージが生じます。

* コネクション確立のレイテンシが低い
* TCP の HoL ブロッキングのない通信の多重化
* コネクションマイグレーションが可能

#### コネクション確立のレイテンシが低い

前述の通り、 TCP + TLS では HTTP 通信が可能になるまで通常では 3 ラウンドトリップを要します。
これに対し、 QUIC では多くの場合コネクションの確立にラウンドトリップを要しません。

QUIC クライアントが QUIC サーバに対してはじめてリクエストを送る際、 1 ラウンドトリップを要します。
この際にクライアントは inchoate CHLO(Client Hello) メッセージを送り、それに対してサーバはコネクションを確立するのに必要な情報と共に REJ(rejection) メッセージを返します。
次回リクエスト送信時からは、 REJ メッセージで受け取った情報を CHLO メッセージに含ませ、それと一緒に暗号化されたリクエストを送ることで、コネクション確立のフェーズを無くすことができます。

![図4. QUIC のコネクション確立](img/fig04.png)

QUIC のコネクション確立フェーズの詳細については後述します。

#### TCP の HoL ブロッキングのない通信の多重化

個人的には QUIC の解決する課題の中で一番インパクトがあったのがこれ、 TCP の HoL(Head of Line) ブロッキングの解消です。

では QUIC ではこの HoL ブロッキングの問題はどうなっているのでしょうか？
と言っても答えは単純明快です。 QUIC ではそもそも TCP ではなく UDP の上に展開しているので、 TCP の HoL ブロッキングは起こりません。
ただし、もちろんパケットロスの検出や再送処理も自前で実装する必要が出てきます。

（ちなみに、 TCP の HoL ブロッキングが無くなったからプロトコル処理でブロックする要素はもう無いんだ！という訳にもいきません。後述しますがヘッダ処理周りでブロックされる可能性があります。。）

shigeki_ohtsu さんによる、前述の [コネクション確立と、 HoL ブロッキングの解消によるインパクトを可視化した動画](https://www.youtube.com/watch?v=bP-8vfDX2ts) が youtube にて公開されています。
QUIC のこの周辺の効果を体感したい際に参照すると良いかもしれません。

#### コネクションマイグレーション

TCP のコネクションは送信元 IP とポート、宛先 IP とポートから識別されるため、例えば送信元 IP が変わった際は一旦コネクションが切れることになります。
これは例えばスマートフォンでモバイル回線から WiFi に切り替わった際に発生することになり、今日では非常に煩わしい問題だと考えられます。

QUIC のコネクションは TCP のコネクションとは違って、独自の 64 ビットの ID によって識別され、これが変更されない限りコネクションは切断されません。


## QUIC 詳解

ここではより QUIC の仕様に踏み込み、具体的にどのようなメッセージをやりとりし、その時何が起きるのかを掘り下げてみます。

まず QUIC の大まかな特徴を確認し、次に QUIC におけるメッセージの単位であるパケットとフレームについて触れ、それらがどうやりとりされてリクエストやレスポンスが処理されるのかを追ってみます。
ちなみにここでは、単に「パケット」「フレーム」と記述した際は、 QUIC におけるメッセージ単位の「QUIC のパケット」「QUIC のフレーム」と解釈してください。

### QUIC の特徴

QUIC は下記のようなプロトコルになっています。

* コネクションによる通信の管理

UDP はコネクションレスなプロトコルですが、その上で展開する QUIC はコネクションの概念が存在します。
TCP ではコネクションを送信元 IP 、送信先 IP 、送信元ポート番号、送信先ポート番号で識別しましたが、 QUIC では各コネクションにランダムかつユニークな符号無し64ビット整数値で表現される ID で識別します。

* ストリームによるコネクション上の通信の多重化

QUIC でも HTTP/2 であったような通信単位であるストリームを持ちます。
ストリームの扱いとしては基本的に HTTP/2 のそれを踏襲していますが、ストリームの管理は QUIC で行いアプリケーションレイヤで行わなくて済むようになるのと、各ストリームの処理は前述の通り TCP の HoL ブロッキングに阻まれることはないという差分もあります。

* フロー制御

QUIC のフロー制御は HTTP/2 のそれと同様に行われます。
すなわち、コネクションレベルとストリームレベルのウインドウサイズを持ち、後述の QUIC における WINDOW_UPDATE フレームで増加管理が行われることになります。
ここで着目したいのは、 TCP + TLS + HTTP/2 では TCP と HTTP/2 でそれぞれフロー制御を行っていたのが、 QUIC においては QUIC のレイヤでのみ行えば済むようになるので、機能的な重複が廃され、かつアプリケーションレイヤの実装がシンプルにできる点です。

* 前方誤り訂正 (FEC, Forward Error Correction)

QUIC パケットがロスした際に再送をなるべく発生させずに済むよう、 QUIC では前方誤り訂正を行う機構を持ちます。
これは仕組みは単純で、 RAID5 のパリティのような情報を持つことになります。

QUIC では幾つかのパケットを合わせて FEC グループという単位にみなします。
その FECグループのパケットの XOR を取ったものを FEC パケットとして送信します。
これにより 1 パケットがロスした場合でも FEC グループのその他のパケットと FEC パケットを用いてそのパケットの復元が可能になります。
ちなみに、前方誤り訂正を使用するか（FEC パケットを送るか）は送信者が選択することができます。

* パケットの再送処理と輻輳制御

QUIC では TCP より進んだパケットの再送処理を行います。

後述の通り、 QUIC のパケットは TCP のようなシーケンス番号を持ちます。
シーケンス番号は QUIC では「転送が開始した順にインクリメントする」よう管理されます。
シーケンス番号のシンプルな管理により、 QUIC では「このシーケンス番号以上のパケットをロスした」ようなパケットロスの通知ができるようになります。

QUIC のパケットロス検出は NACK ベース、つまり ACK による「パケットが届いた」通知ではなく「パケットが届かなかった」通知で行います。
パケットの再送もこの NACK 情報を受け取ってから行います。
また、 QUIC では NACK をレンジで伝えることができ、パケットロスの通知も無駄なく行えます。

### QUIC パケット

QUIC でやり取りされるメッセージにはまずパケットという単位があります。
QUIC のパケットにはヘッダとして下記の情報が付与されます。

* フラグ
* コネクション ID
* 使用する QUIC のバージョン
* シーケンス番号
* FEC グループ番号

QUIC のパケットは下記の 4 種類が存在し、フラグの内容によって識別されます。

1. バージョンネゴシエーションパケット

TBD

2. フレームパケット

QUIC でやりとりするメッセージ単位であるフレームを表現します。
フレームにもいくつか種類が存在します。詳しくは後述します。
フレームパケットには複数のフレームが収まる可能性があります。

![図5. QUIC のパケットとフレーム](img/fig05.png)

3. FEC パケット

前述した前方誤り訂正に用いられるパリティを伝えるためのパケットです。
このパケットのペイロードには具体的には、 FEC グループのパケットのデータ（を必要に応じてパディングを加えたもの）の XOR をとったものが設定されます。

4. Public Reset パケット

TBD

### QUIC フレーム

QUIC も HTTP/2 と同様にフレームという形式でメッセージを表現します。
フレームには大きく分けて、スペシャルフレームとレギュラーフレームの 2 種類が存在します。
この種類ですが、スペシャルフレームは場合に応じてフラグを変更してフレーム内のデータ長を変動させるなどの表現が備わっていますが、レギュラーフレームにはそれが無いなどの差分があります。

#### スペシャルフレーム

* STREAM フレーム

このフレームの役割は二つ、 1) ストリームの新規作成 2) データの送信 です。
HTTP/1.1 におけるリクエストやレスポンスのボディ、 HTTP/2 における最初の HEADERS フレームや DATA フレームの役割に相当します。

* ACK フレーム

TCP の ACK と似たような役割で、ピアに対してパケットが受け取れたことを伝えます。
ACK フレームが返ってこなかった場合は、パケットの再送が必要と判断されます。
TCP の ACK とは違って、ロスしたパケットの Sequence Number 一覧や NACK、 Sequence Number のレンジを伝える方法も提供されています。

* CONGESTION_FEEDBACK フレーム

#### レギュラーフレーム

* PADDING フレーム

名前の通りパディングを示します。
PADDING フレームが現れた際は、そのパケットのペイロードは末尾までパディングとして扱われます。
PADDING フレーム自身のペイロードの内容は特に規定はありません。タイプだけが 0x00 であると決められています。

* RST_STREAM フレーム

基本的に HTTP/2 の RST_STREAM フレームと同じ役割です。
ストリームが不要になってキャンセルする場合や、エラーなどが原因でストリームを終了する場合にやり取りされます。

* CONNECTION_CLOSE フレーム

コネクションが閉じられようとしていることをピアに伝えます。
なお、コネクションが閉じられる際にはその上で動作している全ストリームも閉じられることになります。
もしこの時、データ転送など絶賛稼働中のストリームがあったとしても途中で強制終了されることになります。

* GOAWAY フレーム

基本的に HTTP/2 の GOAWAY フレームと同じ役割です。
近い将来にコネクションが閉じられようとしていることを伝える、 CONNECTION_CLOSE フレームと似たような役割を持つのですが、こちらはすぐにコネクションを閉じることはしません。
動作中のストリームはそのまま処理を続けることができます。ただし、ストリームを新たに開いたり受け付けたりすることはできなくなります。

* WINDOW_UPDATE フレーム

基本的には HTTP/2 の WINDOW_UPDATE フレームと役割は一緒で、フロー制御に使用されます。
ピアに対して、指定ストリームの受信ウインドウサイズが、送信する値分増加することを伝えます。
もしストリーム ID が 0 のストリームに対する WINDOW_UPDATE フレームがやりとりされたら、それはコネクションレベルのウインドウサイズの増加であると解釈されます。

* BLOCKED フレーム

これは前述の WINDOW_UPDATE フレームとも深い関わりのあるフレームです。
データの送信側が、送信準備は整っているのに受信側のウインドウサイズが更新されず、送信処理がブロックされていることを伝えます。
とは言っても、 BLOCKED フレームが送受信された際に何かしなければならないという規定はありません。あくまでブロック情報を伝えるだけの、デバック用途に向いたフレームといえます。

* STOP_WAITING フレーム

プレームのペイロードに設定する値より低い Sequence Number のパケットを待たないようにピアに伝えます。

* PING フレーム

ピアとの接続が使用可能な状態か確かめます。
PING フレームを受け取ったピアは ACK を返すことになっています。

### コネクションの確立

UDP はコネクションレスのプロトコルですが、その上で動作する QUIC にはコネクションの概念があります。
QUIC のコネクションはクライアントがサーバに対して接続要求を開始することで確立します。
コネクション開始時には、使用する QUIC のバージョンと暗号、転送方法のハンドシェイクを行います。

QUIC におけるコネクションの確立は、ID が 1 のストリームで QUIC の crypt handshake メッセージを交わすことで行われます。
handshake メッセージではタグと呼ばれる 4 バイトの値と、それに対応する値で表現されます。
メッセージには下記のような情報が含まれます。

* メッセージのタグ(CHLO, REJ など)
* メッセージに付随するタグのペアの数
* メッセージに付随するタグの名前と値のペア(SNI と SNI で指定する FQDN など)

handshake メッセージによるコネクションの確立は下記のようなフローになります。

1. クライアントがサーバに対して inchoate CHLO(初期 CHLO) を送る

VER タグに使用 QUIC バージョンを設定して CHLO メッセージを送信します。
合わせて、 SNI タグなども必要に応じて送信します。
CHLO メッセージではサーバ設定などの情報を付加することができるのですが、この段階ではクライアントはそれらを持っていないので付与されません。

2. サーバが REJ を返す

SCFG タグにサーバ設定を、 STK タグにソースアドレストークンを、 SNO に今後の CHLO 処理用の

3. クライアントがサーバに対して CHLO を送る

サーバから受け取った STK, SNO, SCID（SCFG の ID）を付与します。

4. サーバが SHLO を返す

クライアントから受け取った CHLO に問題がなければ SHLO を返します。

ここまで実施すると、 QUIC のコネクションが確立されて暗号化された通信が行える状態になります。
後述のコネクションの終了を行った後に再度コネクションを確立する際は、 STK, SNO, SCID 付き CHLO を送ることでラウンドトリップなしにコネクションを確立できます。

### ストリームの管理

各ストリームは idle や open などの状態を持ちます。
これらは HTTP/2 のストリームの状態と同じです。

ストリームにはそれぞれ ID が振られ、それによって識別されます。
ID の振られ方も基本的に HTTP/2 と同様でクライアントが開始した場合は奇数番号、サーバが開始した場合は偶数番号になり、それぞれ新たにストリームを開始する度に番号が増加されていきます。
ただしここで注意すべき点として、 HTTP/2 と異なり ID が 1, 3 番のストリームは特定用途のために予約されているということがあります。
ID が 1 番のストリームは暗号ハンドシェイクに、 3 番のストリームはヘッダ転送用ストリームに使用されます。

### コネクションの終了

QUIC のコネクションは下記の 2 つのどちらかの方法で終了します。

* 明示的な終了

CONNECTION_CLOSE フレームを送って終了する方法です。
CONNECTION_CLOSE フレームを送る前に、事前に GOAWAY フレームを送ってピアにコネクションを終了しようとしていることを伝え、アクティブなストリームの処理が完了するのをなるべく待つようにすることも可能です。

* 暗黙的な終了

タイムアウトにより終了する方法です。
QUIC のコネクションが idle な状態で一定時間（デフォルトでは 30 秒。最大 10 分に設定可能）経過し、かつコネクションネゴシエーション時に ICSL パラメータが含まれていたらコネクションが終了されることになります。
タイムアウトによるコネクション終了を行う場合でも、デフォルトでは CONNECTION_CLOSE フレームを送ることになります。

QUIC コネクションを終了する際、 Public Reset パケットを送ることも可能です。

### QUIC のコネクション確立、リクエスト処理、終了までのフロー

これまでの解説から、 QUIC において新規にコネクションを確立してからリクエストを送信し、レスポンスを受け取ってコネクションを終了するまでの処理の流れの例として下記が挙げられます。

(ここに図)
図. QUIC の処理フロー


## QUIC と HTTP/2 の機能の住み分け

これまで追ってきた QUIC の機能ですが、そのいくつかは RFC7540 で規定されている HTTP/2 の機能と重複しています。
もちろんの事ながら、全く同じ機能を上位レイヤに持たせても無駄でありますから、 QUIC 上で動作する HTTP/2 は QUIC がカバーしてくれない仕事のみを行うべきです。

さて、 TCP + TLS を QUIC に置き換わった際、 HTTP/2 ではどんな処理を行う必要があるのでしょうか。

### ストリーム管理

HTTP/2 で行っていたストリーム管理は、 そのほとんどが QUIC のストリーム管理に任せることができます。
HTTP/2 のレイヤではもはや RFC7540 で記述されていたような、 HEADERS, DATA などのフレームによるヘッダ、ボディの表現を意識しなくてよくなります。
また、 ストリーム ID は QUIC のストリーム ID を用います。

フロー制御についても QUIC のレイヤで行われます。
QUIC のフロー制御は HTTP/2 のそれを機能的にカバーすることができ、 HTTP/2 のレイヤで再度行う必要はありません。
TCP + TLS + HTTP/2 では TCP と HTTP/2 、両方でフロー制御を行っていたのが一本化されるので、これは順当な置き換えと言えそうですね。

### ヘッダ圧縮

QUIC では HTTP/2 と同様、 RFC7541 で規定されている [HPACK](http://tools.ietf.org/html/rfc7541) を使用してヘッダを圧縮します。

しかしながら、実は HPACK を使用することで新たに HoL ブロッキングが発生することになります。。。
というのも、 RFC7541 を読めばわかる通り、 HPACK ではヘッダの圧縮、展開が順番に行われるためです。
例えばヘッダをデコード中、途中のヘッダ内容を格納するフレームがパケットロスにより失われたとしても、その後に続くヘッダをデコードすることは HPACK の仕様上叶わなくなります。

QUIC によるヘッダの送受信はヘッダストリームという、ヘッダ専用ストリーム（とは言っても ID が 3 のストリームを特別にそう扱っているだけ）を用いて行います。
受信処理において、ヘッダの処理が終わってからボディの処理を行うことになります。

### ストリームの優先度とヘッダストリーム

HTTP/2 では 各ストリームに優先度を設定することができました。
これは例えばブラウザ側で Web ページのレンダリングを早く行うために CSS が優先的に求められると判断した際に、それを優先する旨をサーバ側に通知するなどに使うことができます。

QUIC ではストリームの優先度については特になにも行いません。
優先度情報を伝搬させる手段として、ヘッダストリームにおいてヘッダの先頭部分に優先度を設定することができます。
ただし、優先度をどう活用するかは HTTP/2 のレイヤに委ねられることになります。

ヘッダストリームに流れるオクテットストリームは下記のようなフォーマットをとります。

```
     0           3      4          7      8           11   12
+--------+- ... ---+--------+- ... --+--------+- ... ---+------ ...
|     Priority     |    Stream ID    |  Headers length  | Headers
+--------+- ... ---+--------+- ... --+--------+- ... ---+------ ...

* Priority: 32 ビットの優先度値
* Stream ID: QUIC のストリーム ID に紐付いた HTTP/2 における 32 ビットのストリーム ID
* Header length: 32 ビットのヘッダの長さ
* Headers: HPACK で圧縮されたヘッダ
```

### Alternate-Protocol ヘッダによるプロトコルネゴシエーション

HTTP/2 では、クライアントがサーバに対してリクエストを送る前に、サーバが HTTP/2 に対応しているかを調べる方法として TLS の拡張である [NPN](http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04) や [ALPN](https://tools.ietf.org/html/rfc7301) を使ってネゴシエートすることができました。

QUIC ではどうなのかというと、今のところリクエストを送る前にピアが QUIC に対応しているかを調べる手段は提供されていません。
しかしながら TCP + TLS + HTTP (HTTP/1.1, SPDY, HTTP/2) でリクエストを受け付けた際に、「 QUIC でもレスポンスできる」ことを示す手段は QUIC の仕様に定められています。
それが Alternate-Protocol ヘッダです。

Alternate-Protocol ヘッダは下記のような形式をとります。
このヘッダは、ヘッダを返した際のリクエストのドメインに関して、「123 ポートで QUIC でリクエストを受け付けることができる」ことを意味します。
```
"Alternate-Protocol: 123:quic"
```

ただし、このヘッダで確認できるのはサーバ側のプロトコルサポートの都合だけです。
実際に QUIC を使う場合は、中継装置により QUIC （というかそもそも UDP の）通信がブロックされる可能性があります。
従ってクライアントは Alternate-Protocol の情報をもとに QUIC リクエストを投げるのは良いのですが、それを鵜呑みにせず駄目だった際に TCP + TLS + HTTP 通信にフォールバックできるように実装されることが望まれます。


## おわりに

長々と QUIC の紹介をしてきましたが、いかがだったでしょうか？
個人的には TCP と TLS の仕事も受け持ちつつ HTTP/2 の一部機能も引き取る QUIC は非常に野心的なプロトコルであるという感想を抱きました。
一方、実装が非常に複雑かつ困難になると思われるので、 QUIC をサポートするサーバ、クライアントが数多く出現するかというとそういう事もない気もしてしまいます。
さらに、 TCP の HoL ブロッキングなどそういうレベルで性能面に困っているユーザやサービス提供者は数が少なく、 QUIC を積極的に採用しようとする人は現時点ではあまりいないのではとも思います。

なんにせよ QUIC は Internet-Draft が出て間もない若いプロトコルであり今後の動向が非常に気になるところです。

