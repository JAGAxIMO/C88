Title: SHOW BY QUIC!!
Subtitle: 青春はNon-(HoL)Blocking!
Author: @syu_cream
Author(romaji): syu_cream

# SHOW BY QUIC!!

こんにちは、 @syu_cream です。
本記事では、[ITMedia の記事](http://www.itmedia.co.jp/news/articles/1504/20/news046.html) などで最近一部界隈を賑わしている、 Google が提唱する高速プロトコル [QUIC](http://tools.ietf.org/html/draft-tsvwg-quic-protocol-00) について特徴や仕様、そして実装の簡単な紹介をしてみようと思います。

記事の内容には注意を払ってはおりますが、正確性が保証されているものではありません。気になる箇所についてはぜひ、ご自身で仕様のドラフトや実装を読んで確かめてみてください。（そしてこっそりご報告いただけると幸いです ... :D）
また、 QUIC は仕様がドラフトの状態であり、将来的に大きな変更がある可能性がありますのでご注意ください。

なお、 QUIC に関連するプロトコルとして本記事では HTTP/2 についても多く触れますが、詳細な説明は行いません。
QUIC について記述する上で重要な箇所については触れますが、詳細についてはぜひご自身で [RFC7540(HTTP/2 の RFC)](https://tools.ietf.org/html/rfc7540) や、 [ななかINSIDE PRESS vol.5](https://sites.google.com/site/dai7sec/home/c86) を参照しつつ読んで頂ければ幸いです。
ちなみに HTTP/2 と HTTP/2 に関連するヘッダ圧縮フォーマット HPACK の RFC については、それぞれ有志による [RFC7540 の日本語訳](http://summerwind.jp/docs/rfc7540/), [RFC7541 の日本語訳](http://syucream.github.io/hpack-spec-ja/rfc7541-ja.html) が存在し、英語を読むのが面倒という方にも敷居が低い状態になっています。


## QUIC とは

QUIC(Quick UDP Internet Connection) は HTTP 通信の高速化のために HTTP/2 から更に進んだ最適化を行うプロトコルです。
とは言っても HTTP/2 を置き換えるものではなく、 HTTP/2 の下のレイヤで、 TCP と TLS を置き換えるような構想になっています。
図にすると下記のようになります。

(ここに図を貼る)
図1. QUIC と TCP, TLS, HTTP/2 の関係

果たして、既存の TCP + TLS に乗っかったウェブの世界では何が課題になっていて、 QUIC ではそれらがどのように解決されるのでしょうか。
詳しく追ってみましょう。

### TCP + TLS + HTTP/2 の世界

[RFC7540](https://tools.ietf.org/html/rfc7540) では HTTP 通信を高速化するため、 HTTP/1.1 の置き換えとして HTTP/2 が提案されました。
HTTP/2 は TCP, TLS の上に乗っかっており、これによって幾つかの課題が残っている状態です。

HTTP/2 通信を TCP, TLS 上で行うことによって、下記のような課題が未だ残っています。

* HTTP リクエストが送れるようになるまで通常 3 ラウンドトリップ必要
* TCP の HoL ブロッキングによるパフォーマンス低下

### QUIC が実現する世界

TCP + TLS + HTTP/2 の構成と比べ、 QUIC + HTTP/2 の構成では下記のようなアドバンテージが生じます。

* セッション確立のレイテンシが低い
* TCP の HoL ブロッキングのない通信の多重化
* コネクションマイグレーションが可能

また、 TCP, TLS を置き換えることによって、それぞれのレイヤで行っていた処理を柔軟に置き換えることもできます。
ここでは詳細には触れませんが、下記のようなメリットが生じます。

* 柔軟な輻輳制御
* ヘッダとペイロードの認証、暗号化
* 誤り訂正

先に挙げた3つの特徴は、 QUIC を導入する大きなメリットになってきそうです。
詳細を見ていきましょう。

#### セッション確立のレイテンシが低い

ご存知の通り TCP + TLS では HTTP 通信が可能になるまで通常では 3 ラウンドトリップを要します。
TLS の Session resumption や False Start を行うことによってセッション確立までのラウンドトリップを減らすことができますが、それでも 2 ラウンドトリップは要します。

(ここに図)
図2. 一般的な TCP + TLS のセッション確立シーケンス

(ここに図)
図3. Session resumption した際のセッション確立シーケンス


これに対し、 QUIC では多くの場合コネクションの確立にラウンドトリップを要しません。

QUIC クライアントが QUIC サーバに対してはじめてリクエストを送る際、 1 ラウンドトリップを要します。
この際にクライアントは空の CHLO(Client Hello) メッセージを送り、それに対してサーバは REJ(rejection) メッセージを返します。
REJ メッセージには 1) その後の CHLO においてクライアント IP を検証するためのソースアドレストークン 2) サーバ証明書 を含みます。
次回リクエスト送信時からは、 REJ メッセージに含まれたクレデンシャルと一緒に暗号化されたリクエストを CHLO メッセージで送ることで、セッション確立のフェーズを無くすことができます。

(ここに図)
図4. QUIC のセッション確立

(ここに図)
図5. 以前のセッション確立時のクレデンシャルを用いたリクエスト送信

#### TCP の HoL ブロッキングのない通信の多重化

個人的には QUIC の解決する課題の中で一番インパクトがあったのがこれ、 TCP の HoL(Head of Line) ブロッキングの解消です。
... と言うのは良いのですが、そもそも TCP の HoL ブロッキングというのはどのような問題なのでしょうか。

ご存知の通り TCP ではパケットの到着順序が保証されており、送信された順に受信側でバッファから読み取れるようになります。
順序保証によって、より高レイヤでパケットの順序を意識しなくて良くなるという大きなメリットが生じます。
ただし、この順序保証によってパフォーマンスが阻害される場合も存在ます。

下図のように、あるパケットがロスし、それに続くパケットが受信側に到達した場合どうなるでしょうか。
この場合、ロスしたパケットが再送されるわけですが、再送が完了されるまでその後に続くパケットはバッファに蓄積された状態でアプリケーションには処理されません。
このようにパケットロスによってそれに続くパケットの処理がブロックされる問題を、 TCP の HoL ブロッキングと言います。

(ここに図)
図6. TCP の HoL(Head of Line) ブロッキング

では QUIC ではこの HoL ブロッキングの問題はどうなっているのでしょうか？
と言っても答えは単純明快です。 QUIC ではそもそも TCP ではなく UDP の上に展開しているので、 TCP の HoL ブロッキングは起こりません。
ただし、もちろんパケットロスの検出や再送処理も自前で実装する必要が出てきます。

（ちなみに、 TCP の HoL ブロッキングが無くなったからプロトコル処理でブロックする要素はもう無いんだ！という訳にもいきません。後述しますがヘッダ処理周りでブロックされる可能性があります。。）

shigeki_ohtsu さんによる、前述の [セッション確立と、 HoL ブロッキングの解消によるインパクトを可視化した動画](https://www.youtube.com/watch?v=bP-8vfDX2ts) が youtube にて公開されています。
QUIC のこの周辺の効果を体感したい際に参照すると良いかもしれません。

#### コネクションマイグレーション

TCP のコネクションは送信元 IP とポート、宛先 IP とポートから識別されるため、例えば送信元 IP が変わった際は一旦コネクションが切れることになります。
これは例えばスマートフォンでモバイル回線から WiFi に切り替わった際に発生することになり、今日では非常に煩わしい問題だと考えられます。

QUIC のコネクションは TCP のコネクションとは違って、独自の 64 ビットの ID によって識別され、これが変更されない限りコネクションは切断されません。


## QUIC 詳解

QUIC の仕様の draft の内容詳解的なもの


## QUIC と HTTP/2 の機能の住み分け

これまで追ってきた QUIC の機能ですが、そのいくつかは RFC7540 で規定されている HTTP/2 の機能と重複しています。
もちろんの事ながら、全く同じ機能を上位レイヤに持たせても無駄でありますから、 QUIC 上で動作する HTTP/2 は QUIC がカバーしてくれない仕事のみを行うべきです。

さて、 TCP + TLS を QUIC に置き換わった際、 HTTP/2 ではどんな処理を行う必要があるのでしょうか。

### ストリーム管理

HTTP/2 で行っていたストリーム管理は、 そのほとんどが QUIC のストリーム管理に任せることができます。
HTTP/2 のレイヤではもはや RFC7540 で記述されていたような、 HEADERS, DATA などのフレームによるヘッダ、ボディの表現を意識しなくてよくなります。
また、 ストリーム ID は QUIC のストリーム ID を用います。

フロー制御についても QUIC のレイヤで行われます。
QUIC のフロー制御は HTTP/2 のそれを機能的にカバーすることができ、 HTTP/2 のレイヤで再度行う必要はありません。
TCP + TLS + HTTP/2 では TCP と HTTP/2 、両方でフロー制御を行っていたのが一本化されるので、これは順当な置き換えと言えそうですね。

### ヘッダ圧縮

QUIC では HTTP/2 と同様、 RFC7541 で規定されている [HPACK](http://tools.ietf.org/html/rfc7541) を使用してヘッダを圧縮します。

しかしながら、実は HPACK を使用することで新たに HoL ブロッキングが発生することになります。。。
というのも、 RFC7541 を読めばわかる通り、 HPACK ではヘッダの圧縮、展開が順番に行われるためです。
例えばヘッダをデコード中、途中のヘッダ内容を格納するフレームがパケットロスにより失われたとしても、その後に続くヘッダをデコードすることは HPACK の仕様上叶わなくなります。

QUIC によるヘッダの送受信はヘッダストリームという、ヘッダ専用ストリーム（とは言っても ID が 3 のストリームを特別にそう扱っているだけ）を用いて行います。
受信処理において、ヘッダの処理が終わってからボディの処理を行うことになります。

### ストリームの優先度とヘッダストリーム

HTTP/2 では 各ストリームに優先度を設定することができました。
これは例えばブラウザ側で Web ページのレンダリングを早く行うために CSS が優先的に求められると判断した際に、それを優先する旨をサーバ側に通知するなどに使うことができます。

QUIC ではストリームの優先度については特になにも行いません。
優先度情報を伝搬させる手段として、ヘッダストリームにおいてヘッダの先頭部分に優先度を設定することができます。
ただし、優先度をどう活用するかは HTTP/2 のレイヤに委ねられることになります。

ヘッダストリームに流れるオクテットストリームは下記のようなフォーマットをとります。

```
     0           3      4          7      8           11   12
+--------+- ... ---+--------+- ... --+--------+- ... ---+------ ...
|     Priority     |    Stream ID    |  Headers length  | Headers
+--------+- ... ---+--------+- ... --+--------+- ... ---+------ ...

* Priority: 32 ビットの優先度値
* Stream ID: QUIC のストリーム ID に紐付いた HTTP/2 における 32 ビットのストリーム ID
* Header length: 32 ビットのヘッダの長さ
* Headers: HPACK で圧縮されたヘッダ
```

### Alternate-Protocol ヘッダによるプロトコルネゴシエーション

HTTP/2 では、クライアントがサーバに対してリクエストを送る前に、サーバが HTTP/2 に対応しているかを調べる方法として TLS の拡張である [NPN](http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04) や [ALPN](https://tools.ietf.org/html/rfc7301) を使ってネゴシエートすることができました。

QUIC ではどうなのかというと、今のところリクエストを送る前にピアが QUIC に対応しているかを調べる手段は提供されていません。
しかしながら TCP + TLS + HTTP (HTTP/1.1, SPDY, HTTP/2) でリクエストを受け付けた際に、「 QUIC でもレスポンスできる」ことを示す手段は QUIC の仕様に定められています。
それが Alternate-Protocol ヘッダです。

Alternate-Protocol ヘッダは下記のような形式をとります。
このヘッダは、ヘッダを返した際のリクエストのドメインに関して、「123 ポートで QUIC でリクエストを受け付けることができる」ことを意味します。
```
"Alternate-Protocol: 123:quic"
```

ただし、このヘッダで確認できるのはサーバ側のプロトコルサポートの都合だけです。
実際に QUIC を使う場合は、中継装置により QUIC （というかそもそも UDP の）通信がブロックされる可能性があります。
従ってクライアントは Alternate-Protocol の情報をもとに QUIC リクエストを投げるのは良いのですが、それを鵜呑みにせず駄目だった際に TCP + TLS + HTTP 通信にフォールバックできるように実装されることが望まれます。


## Chromium の実装読み

Chromium の実装を読んで、関心のあるところを詳解


## おわりに

